(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{152:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return c})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return m}));var i=n(1),o=n(9),a=(n(0),n(174)),r={title:"Composing Tasks"},c={id:"guide/task-composition",title:"Composing Tasks",description:"So far, we have only looked at running a single Task. In this chapter, we will look at how to _compose_ and _coordinate_ multiple Tasks by examining:",source:"@site/docs/guide/task-composition.md",permalink:"/mgFx/docs/guide/task-composition",editUrl:"https://github.com/ai-labs-team/mgFx/edit/master/website/docs/guide/task-composition.md",sidebar:"someSidebar",previous:{title:"Futures",permalink:"/mgFx/docs/guide/futures"}},s=[{value:"Forms of composition",id:"forms-of-composition",children:[{value:"Explicit composition",id:"explicit-composition",children:[]},{value:"Implicit composition",id:"implicit-composition",children:[]}]},{value:"Considerations",id:"considerations",children:[]},{value:"Conculsions",id:"conculsions",children:[]}],l={rightToc:s};function m(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(a.b)("wrapper",Object(i.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("p",null,"So far, we have only looked at running a single Task. In this chapter, we will look at how to ",Object(a.b)("em",{parentName:"p"},"compose")," and ",Object(a.b)("em",{parentName:"p"},"coordinate")," multiple Tasks by examining:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The forms of composition offered by mgFx and their differences"),Object(a.b)("li",{parentName:"ul"},"Running one Task as a 'child' of another."),Object(a.b)("li",{parentName:"ul"},"The 'environment' available to Task implementations.")),Object(a.b)("h2",{id:"forms-of-composition"},"Forms of composition"),Object(a.b)("p",null,"It is often desirable to implement computer programs such that they consist of distinct, and re-usable 'building blocks'. mgFx offers two patterns to support this premise:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"'Explicit' composition"),Object(a.b)("li",{parentName:"ul"},"'Implicit' or 'hierarchical' composition")),Object(a.b)("h3",{id:"explicit-composition"},"Explicit composition"),Object(a.b)("p",null,"In this pattern, Tasks are designed such that they are each responsible for some discrete unit of functionality, and the developer is expected to explicitly 'chain' the invocation of each Task into another. Take the following example:"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./task-composition-explicit.ts",file:"./task-composition-explicit.ts"}),"import { define, localConnector } from 'mgfx';\nimport { ioTs, t } from '@mgfx/validator-iots';\n\nconst fetchComments = define({\n  name: 'fetchComments',\n  input: ioTs(t.void),\n  output: ioTs(\n    t.array(\n      t.type({\n        id: t.number,\n        userId: t.number,\n        body: t.string,\n      })\n    )\n  ),\n});\n\nconst fetchUser = define({\n  name: 'fetchUser',\n  input: ioTs(t.number),\n  output: ioTs(\n    t.type({\n      name: t.string,\n      email: t.string,\n    })\n  ),\n});\n\nconst connector = localConnector();\n\nconnector\n  .run(fetchComments())\n  .chain((comments) => {\n    // Explicit composition;\n    // Feed output of one `connector.run()` as input to another `connector.run()`\n    const lastComment = comments[comments.length - 1];\n    return connector.run(fetchUser(lastComment.userId));\n  })\n  .value((user) => {\n    // We now have the user who left the last comment\n  });\n")),Object(a.b)("p",null,"Observe how the composition of ",Object(a.b)("inlineCode",{parentName:"p"},"fetchComments")," and ",Object(a.b)("inlineCode",{parentName:"p"},"fetchUser")," are explicit. It is expected that the programmer be aware of the ",Object(a.b)("inlineCode",{parentName:"p"},"fetchComments")," and ",Object(a.b)("inlineCode",{parentName:"p"},"fetchUser")," tasks, and then ",Object(a.b)("em",{parentName:"p"},"explicitly")," chains them together using ",Object(a.b)("inlineCode",{parentName:"p"},"connector.run()"),". If we were to imagine this flow as a sequence diagram, it may look something like this:"),Object(a.b)("img",{src:"/mgFx//diagrams/7b262e061c9673a47910c6e80206f7d8a0c78bea.svg",title:"`mermaid` image"}),Object(a.b)("p",null,"Depending on circumstances, it may not be desirable for Tasks to be explicitly composed like this. That's where 'implicit' composition, or ",Object(a.b)("em",{parentName:"p"},"Hierarchical")," Tasks come into play."),Object(a.b)("h3",{id:"implicit-composition"},"Implicit composition"),Object(a.b)("p",null,"mgFx offers the ability for one Task to run ",Object(a.b)("em",{parentName:"p"},"another")," task in it's implementation. This allows us to create a hierarchy of ",Object(a.b)("em",{parentName:"p"},"Parent")," and ",Object(a.b)("em",{parentName:"p"},"Child")," Tasks, and therefore compose multiple tasks in an implicit manner."),Object(a.b)("p",null,"So far, we've look at how Task implementations accept Input via the first parameter that is passed to the Implementation function. However, there's also a second ",Object(a.b)("em",{parentName:"p"},"Environment")," parameter. The Environment object includes a ",Object(a.b)("inlineCode",{parentName:"p"},"runChild")," method, and has a similar signature to that of ",Object(a.b)("inlineCode",{parentName:"p"},"connector.run()"),":"),Object(a.b)("pre",null,Object(a.b)("code",Object(i.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./task-composition-implicit.ts",file:"./task-composition-implicit.ts"}),"import { define, implement } from 'mgfx';\nimport { ioTs, t } from '@mgfx/validator-iots';\n\nconst def = define({\n  name: 'lastCommenter',\n  input: ioTs(t.void),\n  output: ioTs(\n    t.type({\n      name: t.string,\n      email: t.string,\n    })\n  ),\n});\n\nconst impl = implement(def, (input, environment) => {\n  return (\n    environment\n      // highlight-next-line\n      .runChild(fetchComments())\n      .chain((comments) => {\n        const lastComment = comments[comments.length - 1];\n        // highlight-next-line\n        return environment.runChild(fetchUser(lastComment.userId));\n      })\n  );\n});\n\n// A more compact example using destructuring and `.map()`:\nconst prettyImpl = implement(def, (input, { runChild }) =>\n  runChild(fetchComments())\n    .map((comments) => comments[comments.length - 1].userId)\n    .chain((userId) => runChild(fetchUser(userId)))\n);\n")),Object(a.b)("p",null,"The sequence diagram for this flow is similar to the last one we looked at, with some subtle differences:"),Object(a.b)("img",{src:"/mgFx//diagrams/02aecd3ad93a79aa12a25a6ce57ee07ea7bce053.svg",title:"`mermaid` image"}),Object(a.b)("p",null,"Notice how:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Your Application code now only has to invoke a single Task."),Object(a.b)("li",{parentName:"ul"},"Intermediate processing of data and 'chaining' Tasks together is handled within a Task.")),Object(a.b)("p",null,"The ",Object(a.b)("inlineCode",{parentName:"p"},"runChild")," Environment function allows you to create arbitrarily complex and deep Task hierarchies, whilst maintaining a clean separation of responsibility between discrete units of work."),Object(a.b)("p",null,"Additionally, when a Task is run as a Child of another, this link is expressed in Analysis tools (more on those in the next chapter.)"),Object(a.b)("h2",{id:"considerations"},"Considerations"),Object(a.b)("p",null,"mgFx allows you to pick which of these two approaches best fits your use-case. However, there are some points to consider for each:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("strong",{parentName:"p"},"Does your Task consist of operations against a mixture of different resources?")),Object(a.b)("p",{parentName:"li"},"Use ",Object(a.b)("inlineCode",{parentName:"p"},"runChild")," to break your Task up:"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Each 'child' Task contains behaviour specific to the associated resource."),Object(a.b)("li",{parentName:"ul"},"Better visibility into operations against each resource."))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("strong",{parentName:"p"},"Does your Task perform the same (or similar) sub-processes in a concurrent manner with differing inputs?")),Object(a.b)("p",{parentName:"li"},"Make the 'branch' a Task and invoke it via ",Object(a.b)("inlineCode",{parentName:"p"},"runChild")," within the concurrent region:"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Visibility into each loop."))),Object(a.b)("li",{parentName:"ul"},Object(a.b)("p",{parentName:"li"},Object(a.b)("strong",{parentName:"p"},"Does your Task perform latency-critical and/or intensive loops?")),Object(a.b)("p",{parentName:"li"},"Use a single Task:"),Object(a.b)("ul",{parentName:"li"},Object(a.b)("li",{parentName:"ul"},"Avoids serialization and/or messaging overheads incurred by mgFx - this is minor, but loops can cause this to add up easily.")))),Object(a.b)("h2",{id:"conculsions"},"Conculsions"),Object(a.b)("p",null,"In this chapter we covered:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"The differences between explicit and implicit composition"),Object(a.b)("li",{parentName:"ul"},"The ",Object(a.b)("inlineCode",{parentName:"li"},"runChild")," function available to Task Implementations")),Object(a.b)("p",null,"In the next chapter, we will look at arguably one of mgFx's greatest feature - runtime analysis."))}m.isMDXComponent=!0},174:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var i=n(0),o=n.n(i);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),m=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c({},t,{},e)),n},p=function(e){var t=m(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=Object(i.forwardRef)((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,r=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=m(n),u=i,d=p["".concat(r,".").concat(u)]||p[u]||b[u]||a;return n?o.a.createElement(d,c({ref:t},l,{components:n})):o.a.createElement(d,c({ref:t},l))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,r=new Array(a);r[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,r[1]=c;for(var l=2;l<a;l++)r[l]=n[l];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);