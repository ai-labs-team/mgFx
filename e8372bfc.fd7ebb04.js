(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{168:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return u})),n.d(t,"default",(function(){return c}));var a=n(1),r=n(9),o=(n(0),n(174)),i={title:"Futures"},l={id:"guide/futures",title:"Futures",description:"By now, you should be comfortable with the fundamental components of mgFx, and how to _define_ a Task with certain Input/Output types.",source:"@site/docs/guide/futures.md",permalink:"/mgFx/docs/guide/futures",editUrl:"https://github.com/ai-labs-team/mgFx/edit/master/website/docs/guide/futures.md",sidebar:"someSidebar",previous:{title:"Validation",permalink:"/mgFx/docs/guide/validation"},next:{title:"Composing Tasks",permalink:"/mgFx/docs/guide/task-composition"}},u=[{value:"Enter Futures",id:"enter-futures",children:[]},{value:"How mgFx uses Futures",id:"how-mgfx-uses-futures",children:[{value:"1. In Task Implementations",id:"1-in-task-implementations",children:[]},{value:"2. When running a Task",id:"2-when-running-a-task",children:[]},{value:"Fluent Interface",id:"fluent-interface",children:[]}]},{value:"Tips for newcomers",id:"tips-for-newcomers",children:[{value:"<code>Future#map</code> and <code>Future#chain</code>",id:"futuremap-and-futurechain",children:[]},{value:"Concurrency",id:"concurrency",children:[]},{value:"Promise interop",id:"promise-interop",children:[]}]},{value:"Conclusions",id:"conclusions",children:[]}],s={rightToc:u};function c(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"By now, you should be comfortable with the fundamental components of mgFx, and how to ",Object(o.b)("em",{parentName:"p"},"define")," a Task with certain Input/Output types."),Object(o.b)("p",null,"In this chapter, we shall explore how ",Object(o.b)("em",{parentName:"p"},"asyncronous")," behaviour is handled in mgFx:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"How and why mgFx uses Futures to handle async. behaviour."),Object(o.b)("li",{parentName:"ul"},"A primer on what Futures are."),Object(o.b)("li",{parentName:"ul"},"Some quick tips for newcomers on dealing with Futures.")),Object(o.b)("p",null,"So far, the simple ",Object(o.b)("inlineCode",{parentName:"p"},"sayHello")," task that we've been working on returns a value ",Object(o.b)("em",{parentName:"p"},"synchronously"),". However, communication with the outside world (or even outside of the same OS Process) is rarely like this. Instead, we need a way for Tasks to be to operate in a non-blocking, ",Object(o.b)("em",{parentName:"p"},"asynchronous manner"),"."),Object(o.b)("h2",{id:"enter-futures"},"Enter Futures"),Object(o.b)("p",null,"mgFx uses the ",Object(o.b)("em",{parentName:"p"},"Future")," as the means of representing and handling asychronous Tasks. When compared to ",Object(o.b)("em",{parentName:"p"},"Promises")," (and the ",Object(o.b)("inlineCode",{parentName:"p"},"async/await")," sugar), Futures offer the following advantages:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Futures are ",Object(o.b)("strong",{parentName:"p"},"lazy")," by default, and remain as an abstract data structure until explicitly executed. This closely mirrors the overall goal of mgFx itself, and opens up interesting possibilities for static and/or real-world analysis of Task execution.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Futures are ",Object(o.b)("strong",{parentName:"p"},"cancellable"),". Unlike Promises, the ability to Cancel a pending or in-flight process is built-in to the specification in a predictable manner.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},"Futures have a definite 'error' type. Whereas a Promise only represents a single ",Object(o.b)("strong",{parentName:"p"},"success")," value (",Object(o.b)("inlineCode",{parentName:"p"},"Promise<SuccessVal>"),"), Futures specify two type parameters - ",Object(o.b)("inlineCode",{parentName:"p"},"Future<ErrVal, SuccessVal>"),"."))),Object(o.b)("p",null,"mgFx uses ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/fluture-js/Fluture"}),"Fluture")," to provide an implementation of Futures for JavaScript. Since the mgFx core requires ",Object(o.b)("inlineCode",{parentName:"p"},"fluture")," as a dependency, the functions that it offers for manipulation and inspection will be available to your applications automatically via ",Object(o.b)("inlineCode",{parentName:"p"},"import * from 'fluture'"),"."),Object(o.b)("div",{className:"admonition admonition-info alert alert--info"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"})))),"Stick Around")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"Even if you've never used Futures or Fluture before, stick around. We'll take a look at the basics of dealing with Futures towards the end of this chapter."))),Object(o.b)("h2",{id:"how-mgfx-uses-futures"},"How mgFx uses Futures"),Object(o.b)("p",null,"There are two ways in which mgFx uses Futures to represent async. behaviour:"),Object(o.b)("h3",{id:"1-in-task-implementations"},"1. In Task Implementations"),Object(o.b)("p",null,"This first way may be considered an optional convenience. The Implementation function may return a 'plain' value or a Future that will resolve to an equivalent value. However, mgFx will enforce the ",Object(o.b)("em",{parentName:"p"},"type")," of the value. Take the following examples:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript"}),"import { after } from 'fluture';\nimport { define, implement, validate } from 'mgfx';\n\nconst sayHello = mgFx.define({\n  name: 'sayHello',\n  input: validate.string,\n  output: validate.string,\n});\n\n// VALID - Returns a synchronous value of type `string`.\nimplement(sayHello, (name) => {\n  return `Hello, ${name}!`;\n});\n\n// VALID - Returns a Future of type `string`.\nimplement(sayHello, (name) => {\n  return after(1000)(`Hello, ${name}!`);\n});\n\n// INVALID - Returns a synchronous value of type `number`.\nimplement(sayHello, (name) => {\n  return -99;\n});\n\n// INVALID - Returns a Future of type `number`.\nimplement(sayHello, (name) => {\n  return after(1000)(-99);\n});\n")),Object(o.b)("h3",{id:"2-when-running-a-task"},"2. When running a Task"),Object(o.b)("p",null,"Although Task implementations have the choice of returning a plain value or a Future, the 'initating' side must always treat the process as asynchronous. Therefore, ",Object(o.b)("inlineCode",{parentName:"p"},"connector.run()")," will always return a Future:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./futures-1.ts",file:"./futures-1.ts"}),"import { define, localConnector, validate } from 'mgfx';\n\nconst sayHello = define({\n  name: 'sayHello',\n  input: validate.string,\n  output: validate.string,\n});\n\nlocalConnector()\n  .run(sayHello('World'))\n  // a `Future<any, string>`\n  .map((greeting) => greeting.length)\n  // now a `Future<any, number>`\n  .value((result) => {\n    // equivalent of `fork()`, but ignoring error 'branch'.\n  });\n")),Object(o.b)("h3",{id:"fluent-interface"},"Fluent Interface"),Object(o.b)("p",null,"By default, Fluture's Future's only implement a single method; ",Object(o.b)("inlineCode",{parentName:"p"},".pipe()"),". This method is intended to be used in combination with Fluture's other transforming functions. For example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./futures-2.ts",file:"./futures-2.ts"}),"import { define, localConnector, validate } from 'mgfx';\nimport { map, value } from 'fluture';\n\nconst sayHello = define({\n  name: 'sayHello',\n  input: validate.string,\n  output: validate.string,\n});\n\nlocalConnector()\n  // a `Future<any, string>`\n  .run(sayHello('World'))\n  // now a `Future<any, number>`\n  .pipe(map((value) => value.length))\n  // equivalent of `fork()`, but ignoring error 'branch'.\n  .pipe(value(console.info));\n\n// Is the equivalent of:\nvalue(console.info)(\n  map((value) => value.length)(localConnector().run(sayHello('World')))\n);\n")),Object(o.b)("p",null,"However, many programmers find this syntax a little more cumbersome to work with than should be reasonably expected. Therefore, all Futures emitted by mgFx are automatically augmented with the ",Object(o.b)("a",Object(a.a)({parentName:"p"},{href:"https://github.com/fluture-js/fluenture"}),"Fluenture")," Fluent Interface. This allows the creation of elegant, expressive chains of execution. Here's a more complicated example:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./futures-3.ts",file:"./futures-3.ts"}),"import { ioTs, t } from '@mgfx/validator-iots';\nimport { parallel } from 'fluture';\nimport { define, localConnector } from 'mgfx';\n\nconst enumerateParticipants = define({\n  name: 'enumerateParticipants',\n  input: ioTs(t.void),\n  output: ioTs(t.array(t.string)),\n});\n\nconst sayHello = define({\n  name: 'sayHello',\n  input: ioTs(t.string),\n  output: ioTs(t.void),\n});\n\nconst connector = localConnector();\n\nconnector\n  .run(enumerateParticipants())\n  .map((participants) =>\n    // For each element in the list of 'participants', run the `sayHello` Task:\n    participants.map((name) => connector.run(sayHello(name)))\n  )\n  // This returns a Future that resolves to an Array of Futures.\n  // Let's perform that repeated unit of execution in parallel, with infinite\n  // concurrency:\n  .chain(parallel(Infinity))\n  // Once they've all finished, 'fan in' and derive some aggregate result:\n  .map((results) => results.length)\n  // Finally, invoke this chain of execution, sending the final result to an\n  // observer:\n  .value((resultCount) => {\n    console.info(`Greeted ${resultCount} participants.`);\n  });\n")),Object(o.b)("p",null,"This above example touches on a powerful feature of mgFx; that of ",Object(o.b)("em",{parentName:"p"},"Task Composition"),". However, understanding this concept requires a rudimentary understanding of Futures and some very general patterns and use-cases, which we will outline next."),Object(o.b)("h2",{id:"tips-for-newcomers"},"Tips for newcomers"),Object(o.b)("p",null,"By now, many JavaScript programmers who write asyncronous code are already familiar with the ",Object(o.b)("inlineCode",{parentName:"p"},"Promise"),", and potentially even the newer ",Object(o.b)("inlineCode",{parentName:"p"},"async/await")," syntax. Considering this, here are some tips for those that are experienced with Promises but unfamiliar with Futures:"),Object(o.b)("h3",{id:"futuremap-and-futurechain"},Object(o.b)("inlineCode",{parentName:"h3"},"Future#map")," and ",Object(o.b)("inlineCode",{parentName:"h3"},"Future#chain")),Object(o.b)("p",null,"Once the most appealing features of Promises is that a ",Object(o.b)("inlineCode",{parentName:"p"},".then()")," callback may return a 'plain' value, or another Promise. This allows you to either:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"map")," over the value the Promise resolved to."),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"chain")," the outcome of one Promise to the start of another.")),Object(o.b)("p",null,"Although convenient, this 'two-in-one' API may sometimes be limiting; for example if you wanted a Promise that could resolve to ",Object(o.b)("em",{parentName:"p"},"another Promise"),". Instead, Futures offer two distinct operations:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Future#map(mapFn)")),Object(o.b)("p",{parentName:"li"},Object(o.b)("em",{parentName:"p"},"map")," over the value resolved by a Future, returning a transformed value synchronously.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Future#chain(mapFn)")),Object(o.b)("p",{parentName:"li"},Object(o.b)("em",{parentName:"p"},"chain")," one Future to another, by taking the value resolved by the prior Future and using it to return ",Object(o.b)("em",{parentName:"p"},"another Future"),"."))),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./futures-4.ts",file:"./futures-4.ts"}),"import { Fluent } from 'mgfx/dist/utils/fluenture';\n\ndeclare const stringP: Promise<string>;\ndeclare const isAllowedP: (input: number) => Promise<boolean>;\n\ndeclare const stringF: Fluent<any, string>;\ndeclare const isAllowedF: (input: number) => Fluent<any, boolean>;\n\nstringP\n  // `.then` may return a value...\n  .then((str) => str.length)\n  // ...or another Promise\n  .then((len) => isAllowedP(len));\n\nstringF\n  // *must* use `.map` to return a value...\n  .map((str) => str.length)\n  // ...*must* use `.chain` to return another Future\n  .chain((len) => isAllowedF(len));\n")),Object(o.b)("h3",{id:"concurrency"},"Concurrency"),Object(o.b)("p",null,"Concurrent operations are typically modelled using ",Object(o.b)("inlineCode",{parentName:"p"},"Promise.all"),". The Future analogue to this is ",Object(o.b)("inlineCode",{parentName:"p"},"Fluture.parallel"),":"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./futures-5.ts",file:"./futures-5.ts"}),"import { Fluent } from 'mgfx/dist/utils/fluenture';\nimport { parallel } from 'fluture';\n\ndeclare const somePromises: Array<Promise<string>>;\n\ndeclare const someFutures: Array<Fluent<any, string>>;\n\n// A Promise that will resolve when all input Promises have resolved.\nPromise.all(somePromises);\n\n// A Future that will resolve when all input Futures has resolved.\n// Limits the maximum concurrency to 5\nparallel(5)(someFutures);\n\n// Consider using a concurrency of `Infinity` to mirror `Promise.all`.\n")),Object(o.b)("h3",{id:"promise-interop"},"Promise interop"),Object(o.b)("p",null,"Fluture offers three ways of allowing Promise- and Future-based code to inter-operate:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Future#promise()")),Object(o.b)("p",{parentName:"li"},"Acts as a replacement for ",Object(o.b)("inlineCode",{parentName:"p"},"Future#fork()")," -- it begins execution of the Future, and returns a Promise that will settle with the outcome of that Future."),Object(o.b)("p",{parentName:"li"},"However, one should use this with caution as it does ",Object(o.b)("em",{parentName:"p"},"not")," provide any means of cancelling the Future, unlike ",Object(o.b)("inlineCode",{parentName:"p"},"fork"),", which returns a cancellation function.")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Future#encaseP()")),Object(o.b)("p",{parentName:"li"},"'Encases' a Promise-returning, unary function so that it becomes a Future-returning function:")),Object(o.b)("li",{parentName:"ul"},Object(o.b)("p",{parentName:"li"},Object(o.b)("inlineCode",{parentName:"p"},"Future#attemptP()")),Object(o.b)("p",{parentName:"li"},"Uses the callback provided to create a Future from a Promise. The callback will only be called once the Future begins executing via ",Object(o.b)("inlineCode",{parentName:"p"},"fork")," or similar:"),Object(o.b)("pre",{parentName:"li"},Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-typescript",metastring:"file=./futures-6.ts",file:"./futures-6.ts"}),"import { attemptP, encaseP } from 'fluture';\nimport { Fluent } from 'mgfx/dist/utils/fluenture';\n\ndeclare const stringF: Fluent<any, string>;\ndeclare const isAllowedP: (input: number) => Promise<boolean>;\n\n// (input: number) => Future<unknown, boolean>;\nconst isAllowedF = encaseP(isAllowedP);\n\n// Future<unknown, boolean>;\nconst is99Allowed = attemptP(() => isAllowedP(99));\n\n// Interop\nstringF\n  .map((str) => str.length)\n  .chain(isAllowedF)\n  // Future<any, boolean>\n  .value((isAllowed) => {});\n")))),Object(o.b)("h2",{id:"conclusions"},"Conclusions"),Object(o.b)("p",null,"In this chapter we covered:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"How mgFx uses Futures to encapsulate asynchronous behaviour in Task Implementations and when running a Task."),Object(o.b)("li",{parentName:"ul"},"How mgFx uses a fluent interface to make Futures easier to work with."),Object(o.b)("li",{parentName:"ul"},"Some tips on working with Futures to get you started.")),Object(o.b)("p",null,"Armed with this knowledge, we can proceed to the next chapter, where we'll look at the various ways of ",Object(o.b)("em",{parentName:"p"},"composing Tasks"),"."))}c.isMDXComponent=!0},174:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),c=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l({},t,{},e)),n},p=function(e){var t=c(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},b=Object(a.forwardRef)((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,s=u(e,["components","mdxType","originalType","parentName"]),p=c(n),b=a,d=p["".concat(i,".").concat(b)]||p[b]||m[b]||o;return n?r.a.createElement(d,l({ref:t},s,{components:n})):r.a.createElement(d,l({ref:t},s))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=b;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);